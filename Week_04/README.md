## 🎯 목표
### 자바의 Class 와 Interface에 대해 학습하기.

### 📌 학습할 것
### [클래스](#-클래스)
- [클래스 정의](#-클래스-정의)
- [클래스 구성](#-클래스-구성)
- [클래스 작성](#-클래스-작성)
- [this 키워드](#-this-키워드)
- [super 키워드](#-super-키워드)

### [인터페이스](#-인터페이스)
- [인터페이스 정의](#-인터페이스-정의)
- [인터페이스 구현](#-인터페이스-구현)
- [인터페이스 사용](#-인터페이스-사용)
- [인터페이스 상속](#-인터페이스-상속)
- [인터페이스 메소드](#-인터페이스-메소드)

--- 

## 🇨🇱 클래스
### 💡 클래스 정의

자바에서 클래스란 유사한 특징들의 지닌 객체들의 속성과 행위들을 정의해놓은 설계도와 같은 것이다.

이 설계도를 이용해서 동일한 특징을 객체를 찍어내는 틀과 같은 역할을 한다.

**객체** : 실세계(Real World)에 존재하는 유/무형의 **모든 것**

속성(명사형)과 행위(동사형)를 갖는다.

ex) **자동차** (유형)

- 속성 : 주행거리, 차종, 색상, 마력,,, 
- 행위 : 시동켜기, 시동끄기, 주행하기,,, 
    
ex) **계좌** (무형)

- 속성 : 계좌번호, 예금주, 잔액, 이체한도,,,
- 행위 : 잔액조회, 입금, 출금, 송금,,, 

|클래스|객체|
|:-:|:-:|
|붕어빵틀|붕어빵|
|공장 생산라인|제품|
|건물설계도|건물|

같은 클래스로부터 생성된 객체는 모두 같은 속성과 행위를 가지는데, 객체마다 고유한 속성값을 가질 수 있다.

**즉, 같은 클래스에서 생성된 객체라도 모두 다르다!**

---

클래스는 접근제어자와 함께 class키워드를 사용해서 정의할 수 있다.

```java
[접근 제어자] class XXX{
    필드
    생성자
    메소드
}
```

만약 public class로 클래스를 정의하면 해당 소스코드(.java)의 이름은 반드시 해당 클래스의 이름으로 작성되어야 한다.

> ex) public class Baemung ==> Baemung.java

그리고 클래스를 정의할 땐, 클래스 이름 첫글자는 보통 대문자로 시작하는 파스칼 표기법(PascalCase) 를 사용한다.

클래스안에 다른 클래스를 정의하는 것도 가능하다. 이렇게 하나의 클래스 파일에 여러 클래스를 정의했을 때

[소스코드를 컴파일하면 각 클래스마다 .class 파일이 생성되는 것을 확인할 수 있다.](../../../tree/main/Week_01/#-컴파일-및-실행하는-방법)

클래스를 정의할 때 객체들의 속성과 행위를 필드와 메소드로 정의할 수 있다.

|객체|클래스|
|:-:|:-:|
|속성|필드 (클래스변수(static), 인스턴스변수(non-static))|
|행위|메소드|

- 사람 (객체)
   - 속성 : 이름, 나이
   - 행위 : 나이먹기, 잠자기,,,


- Person (클래스)

> Person.java

```java
public class Person{
    //field
    String name;
    int age;
    
    //constructor
    Person(String name, int age){
        this.name = name;
        this.age = age;
    }
    
    //method
    increaseAge(){}
    Sleep(){}
}
```

### 💡 클래스 구성

#### 1. [**필드(field)**](../../../tree/main/Week_02/#-변수의-스코프와-라이프타임)

클래스의 필드(field)란 클래스에 포함된 멤버 변수(variable)

- **클래스 변수(static variable)**
    - 클래스의 상태
    - 클래스 메모리 로드시 1번만 할당
    
- **인스턴스 변수(instance variable)**
    - 객체의 상태
    - 객체 생성시마다 할당

#### 2. **메소드(method)**

클래스에서 메소드(method)란 어떠한 특정 작업을 수행하기 위한 명령문의 집합

- **클래스 메소드(static method)**
    - 클래스 관점에서의 행위
    - 객체 식별을 해야만하는 작업X
    - 객체를 생성하지 않고도 실행할 수 있는 작업
    
- **인스턴스 메소드(instance method)**
    - 객체 관점에서의 행위
    - 객체 식별을 해야만 하는 작업 O
    - 객체 관련 작업

#### 3. **생성자(constructor)**

클래스를 생성할 때, 필드(인스턴스 변수) 값들을 초기화 시키기 위한 특별한 메소드

객체 초기화의 다양성 제공

#### 4. **중첩 클래스(Nested Class, Inner Class)**
- 클래스 속 클래스
    
#### 5. **Initializer**
- **Static Initializer**
> static{ 실행문장 } : 클래스 메모리 로드시 자동실행 
- **Instance Initializer**
> { 실행문장 } : 객체 생성시 마다 자동실행 --> 생성자 때문에 잘 사용 안함
    
--- 

### 💡 클래스 작성

- 패키지 선언문 (0 or 1)
``` java
package top.sub....; 
// 물리적 : 폴더
// 보통 domain name(Unique!) 역순사용
```

- import문 (0 ~ 多) 
``` java
import top.sub...클래스이름; // 소스 클래스명 바로사용
import top.sub...*; // all classes, interfaces
(not package) : import단위는 패키지 아님!

현 클래스안에서 참조, 사용하는 클래스가 자신과 같은 패키지가 아닌 경우 명시
단, java.lang은 자동으로 불러옴
```

- class 정의 (1 ~ 多)
``` java
** []는 상황에 따라 생략가능함

* 클래스정의
[접근지정자] [활용지정자] class 클래스명 [extends 부모클래스명] [implements 부모인터페이스명,,,] { } 

// 접근지정자
(default),public

// 활용지정자
final : 상속금지
abstract : 추상클래스 (미완성클래스)

// 클래스명
명사형, 첫글자 대문자, 카멜표기법

// extends 
클래스 단일상속

// implements
인터페이스 다중상속



* 멤버정의
[접근지정자] [활용지정자] DataType 변수명 [=초기값];

// 접근지정자
public,protected,(default),private

// 활용지정자
static : 클래스멤버
final : 상수화, 생성자에서 초기화 필수
static final : 어차피 상수이기 때문에 static으로 사용
transient : 객체직렬화 대상제외

// 변수명
명사형, 첫글자 소문자, 카멜표기법

// 초기값
생략시 default값으로 초기화 (0, null, false)



* 메소드정의
[접근지정자] [활용지정자] returnType 메소드명 ([매개변수선언,,,]) [throws Exception명,,,] 
{
    실행문장 
    [return 리턴값]
}

// 접근지정자
public,protected,(default),private

// 활용지정자
static : 객체 생성없이 '클래스이름.메소드이름()'으로 호출 가능, 메소드 내에서 인스턴스 변수 사용 불가
final : 메소드 재정의 X
synchronized : 객체 동기화를 위한 잠금
abstract : 메소드 추상화

// return 리턴값
void : 없음 -> return문 생략가능
not void : return값 명시



* 생성자
[접근지정자] 클래스명 ([매개변수선언,,,]) [throws Exception명,,,] {}

// 접근지정자
public,protected,(default),private

```

### 💡 객체 생성

**객체를 생성할 때는 new 라는 키워드를 사용한다.**

new 키워드는 메모리상에 공간을 할당하고, 할당받은 공간의 주소값을 반환한다.

자바에서 Primitive Type을 제외한 타입 즉, Reference Type의 변수를 초기화 시키면 객체를 Heap 영역에 저장하고 레퍼런스 타입의 변수에는 new 키워드가 주소값을 가지고 Stack 영역에 저장된다.

new라는 키워드는 메모리상에 공간을 할당하고, 할당받은 공간을 주소를 리턴한다.


```java
// 클래스이름 참조변수 = new 생성자호출; -> 객체생성시 초기화를 담당하는 특별한 메소드
Person p1 = new Person("배문규", 29);
Person p2 = new Person("정다운", 29);
```
위 소스코드를 실행하면

1. Class Area에 Person 바이트코드가 올라감

2. new 키워드가 메모리상에 공간을 할당하여 Heap에 인스턴스 변수가 올림

3. new 키워드가 인스턴스변수의 메모리 주소를 리턴하여 Stack에 p1, p2 레퍼런스 변수를 저장해서 올림

![](https://user-images.githubusercontent.com/51703260/132106339-c2ffcdf1-54fc-46d7-982b-e44bece8a755.png)


--- 

### 💡 this 키워드

- non-static 영역(instance 메소드, 생성자, instance initializer)에서 사용함.
- 현재 생성중인, 실행중인 그 객체 자기자신을 일컫음.

**사용법**

#### 1. 지역변수와 인스턴스변수를 구분하기 위해서
```java
void setName(String name){
   this.name=name;
}
```

#### 2. 생성자가 오버로딩된 경우, 자신의 또 다른 생성자를 호출 시 this를 부를 수 있다.
```java
this();
```

#### 3. 자기 자신의 객체를 메소드의 매개변수로 전달하거나 리턴하기 위해서
```java
XXX(){
   return this; // 자기 자신을 리턴
}

YYY(){
   obj.zzz(this); // 자기 자신을 매개변수로 전달
}
```

---

### 💡 super 키워드

- this와 마찬가지로 non-static 영역(instance 메소드, 생성자, instance initializer)에서 사용함.
- 현재 생성중인, 실행중인 객체의 부모를 의미하도록 사용하는 논리적인 개념

**사용법**

#### 1. 자신의 메소드와 부모의 메소드를 구분하기 위해 사용(메소드 재정의 상황)

```java
this.XXX()
super.XXX()

// 참고로, 메소드 말고 멤버는 개념적으로 구분하지 않음
// 부모의 멤버는 자식에게도 있기 때문임
```

#### 2. 자식의 생성자에서 부모 생성자를 명시적으로 호출하기 위해 사용

```java
super();
```

this의 3번 개념은 super에 없다. (있을 필요가 없다.) 

--- 

## 🇮🇳 인터페이스
### 💡 인터페이스 정의

--- 

### 💡 인터페이스 구현

--- 

### 💡 인터페이스 사용

--- 

### 💡 인터페이스 상속

--- 

### 💡 인터페이스 메소드
